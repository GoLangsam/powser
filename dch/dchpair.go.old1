// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test concurrency primitives: power series.

package dch

import (
	"github.com/GoLangsam/ps/rat"
)

type DchPair [2]*Dch

func NewPair() (pair DchPair) {
	pair[0] = New()
	pair[1] = New()
	return pair
}

// Split reads a single demand channel and replicates its
// output onto two, which may be read at different rates.
// A process is created at first demand and dies
// after the data has been sent to both outputs.
//
// When multiple generations of split exist, the newest
// will service requests on one channel, which is
// always renamed to be out[0]; the oldest will service
// requests on the other channel, out[1].  All generations but the
// newest hold queued data that has already been sent to
// out[0].  When data has finally been sent to out[1],
// a signal on the release-wait channel tells the next newer
// generation to begin servicing out[1].
//
func (out DchPair) Split(in *Dch) {
	release := make(chan struct{})
	go out.dosplit(in, release)
	release <- struct{}{}
}

func (out DchPair) dosplit(in *Dch, wait <-chan struct{}) {
	both := false // do not service both channels

	reqI, datI := in.From()
	req0, dat0 := out[0].Into()
	req1, dat1 := out[1].Into()

	select {
	case <-req0:

	case <-wait:
		both = true
		select {
		case <-req0:

		case <-req1: // swap
			out[0], out[1] = out[1], out[0]
			req0, req1 = req1, req0
			dat0, dat1 = dat1, dat0
		}
	}

	reqI <- struct{}{}
	release := make(chan struct{})
	go out.dosplit(in, release)
	dat := <-datI
	dat0 <- dat
	if !both {
		<-wait
	}
	<-req1
	dat1 <- dat
	release <- struct{}{}
}

// Get a pair from a pair of demand channels
func (in DchPair) Get() (out [2]*rat.Rat) {
	n := len(in)
	if n != 2 {
		panic("bad n in Get2")
	}

	req := make([]chan<- struct{}, 0, n)
	snd := make([]<-chan *rat.Rat, 0, n) // we might send here
	dat := make([]<-chan *rat.Rat, 0, n) // we shall send here

	for i := 0; i < n; i++ {
		req[i], snd[i] = in[i].From()
		dat[i] = nil
	}

	for n = 2 * n; n > 0; n-- {

		select {
		case req[0] <- struct{}{}:
			dat[0] = snd[0]
			req[0] = nil
		case req[1] <- struct{}{}:
			dat[1] = snd[1]
			req[1] = nil
		case it := <-dat[0]:
			out[0] = it
			dat[0] = nil
		case it := <-dat[1]:
			out[1] = it
			dat[1] = nil
		}
	}
	return out
}
